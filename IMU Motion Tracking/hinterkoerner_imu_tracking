import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
import os

# ----------------------------
# 1. Load CSV files
# ----------------------------
accel_df = pd.read_csv(r'IMU Motion Tracking/data/hinterkoerner_acceleration.csv')
gyro_df = pd.read_csv(r'IMU Motion Tracking/data/hinterkoerner_gyroscope.csv')

# Rename columns for consistency
accel_df.rename(columns={'Timestamp': 'time', 'X': 'accel_x', 'Y': 'accel_y', 'Z': 'accel_z'}, inplace=True)
gyro_df.rename(columns={'Timestamp': 'time', 'X': 'gyro_x', 'Y': 'gyro_y', 'Z': 'gyro_z'}, inplace=True)

# Convert time to datetime
accel_df['time'] = pd.to_datetime(accel_df['time'], format='%d-%b-%Y %H:%M:%S.%f')
gyro_df['time'] = pd.to_datetime(gyro_df['time'], format='%d-%b-%Y %H:%M:%S.%f')

# ----------------------------
# 2. Merge on nearest timestamp
# ----------------------------
df = pd.merge_asof(
    accel_df.sort_values('time'),
    gyro_df.sort_values('time'),
    on='time',
    direction='nearest',
    tolerance=pd.Timedelta(milliseconds=100)
)

# Normalize time to start at zero (seconds)
df['time'] = (df['time'] - df['time'].iloc[0]).dt.total_seconds()

# Ensure sensor columns are float
sensor_cols = ['accel_x','accel_y','accel_z','gyro_x','gyro_y','gyro_z']
df[sensor_cols] = df[sensor_cols].astype(float)

# ----------------------------
# 3. Sampling rate calculation
# ----------------------------
dt = df['time'].diff().median()
fs = 1 / dt
print(f"Total samples: {len(df)}")
print(f"Duration: {df['time'].max():.2f} seconds")
print(f"Sampling rate: {fs:.1f} Hz")

# ----------------------------
# 4. Gyroscope unit check
# ----------------------------
gyro_cols = ['gyro_x', 'gyro_y', 'gyro_z']
max_gyro_value = df[gyro_cols].abs().quantile(0.95).max()

if max_gyro_value > 20:
    print(f"Gyroscope values appear to be in deg/s (max: {max_gyro_value:.1f})")
    df[gyro_cols] = np.deg2rad(df[gyro_cols])
    print("Converted gyroscope data from deg/s to rad/s.")
else:
    print(f"Gyroscope values appear to be in rad/s (max: {max_gyro_value:.2f})")

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

# Plot raw data
# Acceleration
ax1.plot(df['time'], df['accel_x'], label='X', alpha=0.7)
ax1.plot(df['time'], df['accel_y'], label='Y', alpha=0.7)
ax1.plot(df['time'], df['accel_z'], label='Z', alpha=0.7)
ax1.set_ylabel('Acceleration (m/s²)')
ax1.set_title('Raw Accelerometer Data')
ax1.legend()
ax1.grid(True)

# Gyroscope
ax2.plot(df['time'], df['gyro_x'], label='X', alpha=0.7)
ax2.plot(df['time'], df['gyro_y'], label='Y', alpha=0.7)
ax2.plot(df['time'], df['gyro_z'], label='Z', alpha=0.7)
ax2.set_ylabel('Angular Velocity (rad/s)')
ax2.set_xlabel('Time (s)')
ax2.set_title('Raw Gyroscope Data')
ax2.legend()
ax2.grid(True)

plt.tight_layout()
plt.savefig('IMU Motion Tracking/figures/01_raw_sensor_data.png', dpi=300)

# ----------------------------
# 5. Butterworth low-pass filter
# ----------------------------
def butter_lowpass_filter(data, cutoff, fs, order=2):
    """Apply a Butterworth low-pass filter to a 1D array."""
    nyquist = 0.5 * fs
    if cutoff >= nyquist:
        raise ValueError(f"Cutoff frequency ({cutoff}) must be < Nyquist ({nyquist})")
    normal_cutoff = cutoff / nyquist
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return filtfilt(b, a, data)

cutoff_frequency = 5  # Hz (adjust as needed)

# Apply filter to all sensor columns, filling NaNs if any
for col in sensor_cols:
    data = df[col].ffill().bfill().values  # UPDATED: no FutureWarning
    df[col + '_filt'] = butter_lowpass_filter(data, cutoff_frequency, fs)

# ----------------------------
# 6. Plot filtered vs raw data (Acceleration)
# ----------------------------
fig, axes = plt.subplots(3, 1, figsize=(12, 10))

for i, axis in enumerate(['x', 'y', 'z']):
    axes[i].plot(df['time'], df[f'accel_{axis}'], label='Raw', alpha=0.5, linewidth=0.5)
    axes[i].plot(df['time'], df[f'accel_{axis}_filt'], label='Filtered', linewidth=2)
    axes[i].set_ylabel(f'Acceleration {axis.upper()} (m/s²)')
    axes[i].legend()
    axes[i].grid(True)

axes[2].set_xlabel('Time (s)')
plt.suptitle('Raw vs. Filtered Acceleration')
plt.tight_layout()
fig_folder = r'IMU Motion Tracking/figures'
os.makedirs(fig_folder, exist_ok=True)
plt.savefig(os.path.join(fig_folder, '02_filtered_acceleration.png'), dpi=300)
plt.show(block=False)
plt.close(fig)

# ----------------------------
# 7. Plot filtered vs raw data (Gyroscope)
# ----------------------------
fig, axes = plt.subplots(3, 1, figsize=(12, 10))

for i, axis in enumerate(['x', 'y', 'z']):
    axes[i].plot(df['time'], df[f'gyro_{axis}'], label='Raw', alpha=0.5, linewidth=0.5)
    axes[i].plot(df['time'], df[f'gyro_{axis}_filt'], label='Filtered', linewidth=2)
    axes[i].set_ylabel(f'Angular Velocity {axis.upper()} (rad/s)')
    axes[i].legend()
    axes[i].grid(True)

axes[2].set_xlabel('Time (s)')
plt.suptitle('Raw vs. Filtered Gyroscope')
plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '03_filtered_gyroscope.png'), dpi=300)

# ----------------------------
# 8. Orientation estimation using Madgwick filter
# ----------------------------
sampling_rate = fs  # Hz

from ahrs.filters import Madgwick

# Initialize the Madgwick filter
madgwick = Madgwick(frequency=sampling_rate, gain=0.1)

# Prepare arrays for orientation storage
quaternions = np.zeros((len(df), 4))
quaternions[0] = np.array([1.0, 0.0, 0.0, 0.0])  # Initial orientation (identity)

# Iterate through sensor measurements
for i in range(1, len(df)):
    # Extract accelerometer and gyroscope values
    accel = df[['accel_x_filt', 'accel_y_filt', 'accel_z_filt']].iloc[i].values
    gyro = df[['gyro_x_filt', 'gyro_y_filt', 'gyro_z_filt']].iloc[i].values
    
    # Normalize accelerometer (Madgwick uses it as direction reference)
    accel_norm = accel / (np.linalg.norm(accel) + 1e-12)
    
    # Update orientation estimate
    quaternions[i] = madgwick.updateIMU(quaternions[i-1], gyr=gyro, acc=accel_norm)

# Store quaternions in dataframe
df['q_w'] = quaternions[:, 0]
df['q_x'] = quaternions[:, 1]
df['q_y'] = quaternions[:, 2]
df['q_z'] = quaternions[:, 3]

from scipy.spatial.transform import Rotation as R

# Convert quaternions to Euler angles
# Note: R.from_quat expects [x, y, z, w] format, but our quaternions are [w, x, y, z]
# We need to reorder: take columns [1,2,3,0] to convert from [w,x,y,z] to [x,y,z,w]
quaternions_scipy = quaternions[:, [1, 2, 3, 0]]
rotations = R.from_quat(quaternions_scipy)
euler_angles = rotations.as_euler('xyz', degrees=True)

df['roll'] = euler_angles[:, 0]
df['pitch'] = euler_angles[:, 1]
df['yaw'] = euler_angles[:, 2]

# Plot orientation over time
fig, axes = plt.subplots(3, 1, figsize=(12, 8))

axes[0].plot(df['time'], df['roll'])
axes[0].set_ylabel('Roll (degrees)')
axes[0].grid(True)

axes[1].plot(df['time'], df['pitch'])
axes[1].set_ylabel('Pitch (degrees)')
axes[1].grid(True)

axes[2].plot(df['time'], df['yaw'])
axes[2].set_ylabel('Yaw (degrees)')
axes[2].set_xlabel('Time (s)')
axes[2].grid(True)

plt.suptitle('Device Orientation Over Time')
plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '04_orientation_euler.png'), dpi=300)

# ----------------------------
# 9. Transform accelerations to global frame
# ----------------------------

from scipy.spatial.transform import Rotation as R

# Create array for global accelerations
accel_global = np.zeros((len(df), 3))

for i in range(len(df)):
    # Get local acceleration (in phone frame)
    accel_local = df[['accel_x_filt', 'accel_y_filt', 'accel_z_filt']].iloc[i].values
    
    # Get rotation at this time step
    q = quaternions[i]  # Our format: [w, x, y, z]
    rotation = R.from_quat([q[1], q[2], q[3], q[0]])  # scipy expects [x, y, z, w]
    
    # Rotate acceleration to global frame
    accel_global[i] = rotation.apply(accel_local)

# Store global accelerations
df['accel_global_x'] = accel_global[:, 0]
df['accel_global_y'] = accel_global[:, 1]
df['accel_global_z'] = accel_global[:, 2]

# Gravity is approximately 9.81 m/s² in the negative Z direction
# Estimate gravity from the mean during stationary periods
baseline_global = df.iloc[:int(2*sampling_rate)]  # First 2 seconds
gravity_global = baseline_global[['accel_global_x', 'accel_global_y', 'accel_global_z']].mean()

print(f"Estimated gravity vector: {gravity_global.values}")

# Remove gravity
df['accel_motion_x'] = df['accel_global_x'] - gravity_global['accel_global_x']
df['accel_motion_y'] = df['accel_global_y'] - gravity_global['accel_global_y']
df['accel_motion_z'] = df['accel_global_z'] - gravity_global['accel_global_z']

fig, axes = plt.subplots(3, 1, figsize=(12, 8))

axes[0].plot(df['time'], df['accel_motion_x'])
axes[0].set_ylabel('Global X (m/s²)')
axes[0].grid(True)

axes[1].plot(df['time'], df['accel_motion_y'])
axes[1].set_ylabel('Global Y (m/s²)')
axes[1].grid(True)

axes[2].plot(df['time'], df['accel_motion_z'])
axes[2].set_ylabel('Global Z (m/s²)')
axes[2].set_xlabel('Time (s)')
axes[2].grid(True)

plt.suptitle('Motion Acceleration in Global Coordinates')
plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '05_global_acceleration.png'), dpi=300)

# ----------------------------
# 10. Integrate acceleration to get velocity and position
# ----------------------------

from scipy.signal import detrend

# Calculate time step for each sample
dt_array = df['time'].diff().fillna(0).values

# Initialize velocity and position arrays
velocity = np.zeros((len(df), 3))
position = np.zeros((len(df), 3))

# Extract detrended acceleration arrays
accel_x = detrend(df['accel_motion_x'].values)
accel_y = detrend(df['accel_motion_y'].values)
accel_z = detrend(df['accel_motion_z'].values)

# Numerical integration using trapezoidal rule
for i in range(1, len(df)):
    accel_current = np.array([accel_x[i], accel_y[i], accel_z[i]])
    accel_previous = np.array([accel_x[i-1], accel_y[i-1], accel_z[i-1]])
    velocity[i] = velocity[i-1] + 0.5 * (accel_previous + accel_current) * dt_array[i]
    position[i] = position[i-1] + 0.5 * (velocity[i-1] + velocity[i]) * dt_array[i]

# Store results
df['vel_x'] = velocity[:, 0]
df['vel_y'] = velocity[:, 1]
df['vel_z'] = velocity[:, 2]

df['pos_x'] = position[:, 0]
df['pos_y'] = position[:, 1]
df['pos_z'] = position[:, 2]

fig, axes = plt.subplots(3, 1, figsize=(12, 8))

axes[0].plot(df['time'], df['vel_x'])
axes[0].set_ylabel('Velocity X (m/s)')
axes[0].grid(True)

axes[1].plot(df['time'], df['vel_y'])
axes[1].set_ylabel('Velocity Y (m/s)')
axes[1].grid(True)

axes[2].plot(df['time'], df['vel_z'])
axes[2].set_ylabel('Velocity Z (m/s)')
axes[2].set_xlabel('Time (s)')
axes[2].grid(True)

plt.suptitle('Reconstructed Velocity')
plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '06_velocity.png'), dpi=300)

# ----------------------------
# 11. Plot 2D trajectory (top view)
# ----------------------------

plt.figure(figsize=(10, 10))
plt.plot(df['pos_x'], df['pos_y'], linewidth=2, label='Trajectory')
plt.scatter(df['pos_x'].iloc[0], df['pos_y'].iloc[0], 
            c='green', s=200, marker='o', label='Start', zorder=5)
plt.scatter(df['pos_x'].iloc[-1], df['pos_y'].iloc[-1], 
            c='red', s=200, marker='X', label='End', zorder=5)
plt.xlabel('X Position (m)')
plt.ylabel('Y Position (m)')
plt.title('Reconstructed Trajectory (Top View)')
plt.axis('equal')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '07_trajectory_2d.png'), dpi=300)

# ----------------------------
# 12. Plot 3D trajectory
# ----------------------------

from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection='3d')

# Plot trajectory
ax.plot(df['pos_x'], df['pos_y'], df['pos_z'], linewidth=2, label='Trajectory')

# Mark start and end
ax.scatter(df['pos_x'].iloc[0], df['pos_y'].iloc[0], df['pos_z'].iloc[0], 
           c='green', s=200, marker='o', label='Start')
ax.scatter(df['pos_x'].iloc[-1], df['pos_y'].iloc[-1], df['pos_z'].iloc[-1], 
           c='red', s=200, marker='X', label='End')

ax.set_xlabel('X Position (m)')
ax.set_ylabel('Y Position (m)')
ax.set_zlabel('Z Position (m)')
ax.set_title('Reconstructed 3D Trajectory')
ax.legend()

plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '08_trajectory_3d.png'), dpi=300)

# ----------------------------
# 13. Calculate and print reconstructed distance
# ----------------------------

# Calculate Euclidean distance from start to end
start_pos = np.array([df['pos_x'].iloc[0], df['pos_y'].iloc[0], df['pos_z'].iloc[0]])
end_pos = np.array([df['pos_x'].iloc[-1], df['pos_y'].iloc[-1], df['pos_z'].iloc[-1]])
reconstructed_distance = np.linalg.norm(end_pos - start_pos)

print(f"Reconstructed distance: {reconstructed_distance:.3f} meters")
print(f"Start position: {start_pos}")
print(f"End position: {end_pos}")

# If you measured the actual distance, compare:
# actual_distance = 1.0  # meters (your measurement)
# error = abs(reconstructed_distance - actual_distance)
# print(f"Error: {error:.3f} meters ({error/actual_distance*100:.1f}%)")

# ----------------------------
# 14. Zero Velocity Update (ZUPT) Implementation - Improved
# ----------------------------

# Calculate acceleration magnitude in global frame
accel_magnitude = np.sqrt(
    df['accel_motion_x']**2 + 
    df['accel_motion_y']**2 + 
    df['accel_motion_z']**2
)

# Define stationary threshold
stationary_threshold = 0.2  # m/s²
is_stationary = accel_magnitude < stationary_threshold

# Apply ZUPT: reset velocity during stationary periods
velocity_zupt = velocity.copy()
for i in range(len(df)):
    if is_stationary.iloc[i]:
        velocity_zupt[i] = np.array([0.0, 0.0, 0.0])

# Reintegrate position with ZUPT-corrected velocity using trapezoidal rule
position_zupt = np.zeros((len(df), 3))
for i in range(1, len(df)):
    position_zupt[i] = position_zupt[i-1] + 0.5 * (velocity_zupt[i-1] + velocity_zupt[i]) * dt_array[i]

# Compare trajectories
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

ax1.plot(position[:, 0], position[:, 1], label='Without ZUPT')
ax1.set_xlabel('X (m)')
ax1.set_ylabel('Y (m)')
ax1.set_title('Trajectory Without ZUPT')
ax1.axis('equal')
ax1.grid(True)

ax2.plot(position_zupt[:, 0], position_zupt[:, 1], label='With ZUPT', color='orange')
ax2.set_xlabel('X (m)')
ax2.set_ylabel('Y (m)')
ax2.set_title('Trajectory With ZUPT')
ax2.axis('equal')
ax2.grid(True)

plt.tight_layout()
plt.savefig(os.path.join(fig_folder, '09_zupt_comparison.png'), dpi=300)
plt.show()